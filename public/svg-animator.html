<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
    #container { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
    #container svg { width: 100%; height: 100%; max-width: 100%; max-height: 100%; }
  </style>
</head>
<body>
  <div id="container"></div>
  <script>
    const CROSSFADE_DURATION = 500;
    const SWITCH_IMAGES_AFTER = 1500;
    
    let animationTimeout = null;
    let frameIndex = 0;
    let frameGroups = [];
    let isPlaying = true;

    function getParams() {
      const params = new URLSearchParams(window.location.search);
      return {
        slug: params.get('slug'),
        gender: params.get('gender') || 'male',
        playing: params.get('playing') !== 'false'
      };
    }

    function findFrameGroups(svg) {
      const groups = [];
      const letters = 'abcdefghijk';
      for (const letter of letters) {
        let group = svg.querySelector(`g[id="${letter}"]`);
        if (!group) {
          group = svg.querySelector(`g[id^="${letter}_"]`);
        }
        if (group) {
          groups.push(group);
        }
      }
      return groups;
    }

    function animateOpacity(element, targetOpacity, duration, callback) {
      const computedStyle = window.getComputedStyle(element);
      const startOpacity = parseFloat(computedStyle.opacity) || (targetOpacity === 1 ? 0 : 1);
      const startTime = performance.now();

      function step(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeProgress = progress < 0.5 
          ? 2 * progress * progress 
          : -1 + (4 - 2 * progress) * progress;
        const currentOpacity = startOpacity + (targetOpacity - startOpacity) * easeProgress;
        
        element.style.setProperty('opacity', currentOpacity.toString(), 'important');
        
        if (progress < 1) {
          requestAnimationFrame(step);
        } else {
          element.style.setProperty('opacity', targetOpacity.toString(), 'important');
          if (callback) callback();
        }
      }
      
      requestAnimationFrame(step);
    }

    function crossFade() {
      if (!isPlaying || frameGroups.length <= 1) return;
      
      const currentIndex = frameIndex;
      const nextIndex = (currentIndex + 1) % frameGroups.length;
      const currentGroup = frameGroups[currentIndex];
      const nextGroup = frameGroups[nextIndex];
      
      if (currentGroup && nextGroup) {
        animateOpacity(currentGroup, 0, CROSSFADE_DURATION);
        animateOpacity(nextGroup, 1, CROSSFADE_DURATION, () => {
          frameIndex = nextIndex;
          animationTimeout = setTimeout(crossFade, SWITCH_IMAGES_AFTER);
        });
      }
    }

    function initAnimation(svg) {
      frameGroups = findFrameGroups(svg);
      if (frameGroups.length <= 1) return;

      // Initialize all frames
      frameGroups.forEach((group, idx) => {
        group.removeAttribute('display');
        group.classList.forEach(cls => {
          if (cls.includes('st0') || cls.includes('hidden')) {
            group.classList.remove(cls);
          }
        });
        group.style.setProperty('opacity', idx === 0 ? '1' : '0', 'important');
        group.style.setProperty('display', 'inline', 'important');
        group.style.setProperty('visibility', 'visible', 'important');
      });

      frameIndex = 0;
      
      if (isPlaying) {
        animationTimeout = setTimeout(crossFade, SWITCH_IMAGES_AFTER);
      }
    }

    function loadSvg(slug, gender) {
      const container = document.getElementById('container');
      const svgPath = `/new-exercise/${slug}/${gender}.svg`;
      
      fetch(svgPath)
        .then(response => {
          if (!response.ok) {
            // Fallback to old path
            return fetch(`/exercise-images/${slug}/${gender}.svg`);
          }
          return response;
        })
        .then(response => response.text())
        .then(svgText => {
          container.innerHTML = svgText;
          const svg = container.querySelector('svg');
          if (svg) {
            initAnimation(svg);
          }
        })
        .catch(err => {
          console.error('Failed to load SVG:', err);
        });
    }

    // Handle messages from parent (for play/pause control)
    window.addEventListener('message', (event) => {
      if (event.data.type === 'setPlaying') {
        isPlaying = event.data.playing;
        if (isPlaying && frameGroups.length > 1 && !animationTimeout) {
          animationTimeout = setTimeout(crossFade, SWITCH_IMAGES_AFTER);
        } else if (!isPlaying && animationTimeout) {
          clearTimeout(animationTimeout);
          animationTimeout = null;
        }
      }
    });

    // Initialize
    const params = getParams();
    isPlaying = params.playing;
    if (params.slug) {
      loadSvg(params.slug, params.gender);
    }
  </script>
</body>
</html>
